import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn import linear_model
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn import preprocessing
import scipy.stats as stats
from scipy.stats import norm
import statistics
import math

df = pd.read_excel('final_steer.xlsx')
df.head()

nor_accx_steer = np.array(df['Acc X(m/s^2)'])
nor_accx_steer

"""# DAY 5 DATA COG"""

dfc = pd.read_excel('cog_drive.xlsx')
dfc.head()

filtered_final = dfc[dfc['Vel Y(m/s)'] >= -20.16]
final = filtered_final[filtered_final['Vel Y(m/s)']<=20]



final['Vel Y(m/s)'].sort_values()

final.to_excel('final_steer.xlsx')
final = final.iloc[:-1]
dfc = final
dfc

"""# ANALYSIS OF DATA OF ACC_X"""

start_time = pd.Timestamp('2023-07-01 00:00:00')
time_interval = pd.Timedelta(seconds=0.5)
timestamps = [start_time + i * time_interval for i in range(len(dfc['Acc X(m/s^2)']))]

# Create scatter plot
plt.figure(figsize=(10, 6))
plt.scatter(timestamps, dfc['Acc X(m/s^2)'], alpha=0.6, color='g')

# Set plot title and labels
plt.title('Acceleration vs Time')
plt.xlabel('Timestamp')
plt.ylabel('Acceleration_X (m/s^2)')

# Improve the readability of the x-axis by formatting the timestamps
plt.gcf().autofmt_xdate()

nor_accx = np.array(dfc['Acc X(m/s^2)'])
nor_accx

mu = np.mean(nor_accx)
sigma = np.std(nor_accx)
print(mu)
print(sigma)

# Calculate mean and standard deviation
mu = np.mean(nor_accx)
sigma = np.std(nor_accx)

# Generate data points for the Gaussian curve
x = np.linspace(mu - 3*sigma, mu + 3*sigma, 1000)
y = norm.pdf(x, mu, sigma)

# Plot the Gaussian distribution
plt.figure(figsize=(8, 6))  # Adjust figure size as needed
plt.plot(x, y, label=f'Gaussian Curve ($\mu={mu:.2f}$, $\sigma={sigma:.2f}$)')
plt.title('Gaussian Distribution')
plt.xlabel('x')
plt.ylabel('Probability Density')
plt.grid(True)
plt.legend()

# Add vertical lines for mean and ±1σ, ±2σ
plt.axvline(mu, color='r', linestyle='--', linewidth=1, label=f'Mean ($\mu={mu:.2f}$)')
plt.axvline(mu + sigma, color='g', linestyle='--', linewidth=1, label=f'$\mu+\sigma={mu+sigma:.2f}$')
plt.axvline(mu - sigma, color='g', linestyle='--', linewidth=1, label=f'$\mu-\sigma={mu-sigma:.2f}$')
plt.axvline(mu + 2*sigma, color='b', linestyle='--', linewidth=1, label=f'$\mu+2\sigma={mu+2*sigma:.2f}$')
plt.axvline(mu - 2*sigma, color='b', linestyle='--', linewidth=1, label=f'$\mu-2\sigma={mu-2*sigma:.2f}$')

plt.legend()
plt.tight_layout()
plt.show()

# Plot the histogram
plt.hist(nor_accx, bins=10, density=True, alpha=0.6, color='g')

# Plot the normal distribution curve
xmin, xmax = plt.xlim()
x = np.linspace(xmin, xmax, 100)
p = stats.norm.pdf(x, 0, 1)
plt.plot(x, p, 'k', linewidth=2)

title = "Normalized 'Acc X(m/s^2)' - Z-Scores"
plt.title(title)
plt.xlabel('Z-Score')
plt.ylabel('Density')
plt.show()

"""# ANALYZING DATA OF ACC_Y"""

start_time = pd.Timestamp('2023-07-01 00:00:00')
time_interval = pd.Timedelta(seconds=0.5)
timestamps = [start_time + i * time_interval for i in range(len(dfc['Acc Y(m/s^2)']))]

# Create scatter plot
plt.figure(figsize=(10, 6))
plt.scatter(timestamps, dfc['Acc Y(m/s^2)'], alpha=0.6, color='g')

# Set plot title and labels
plt.title('Acceleration vs Time')
plt.xlabel('Timestamp')
plt.ylabel('Acceleration_Y (m/s^2)')

# Improve the readability of the x-axis by formatting the timestamps
plt.gcf().autofmt_xdate()

nor_accy = np.array(dfc['Acc Y(m/s^2)'])
nor_accy

mu = np.mean(nor_accy)
sigma = np.std(nor_accy)
print(mu)
print(sigma)

# Calculate mean and standard deviation
mu = np.mean(nor_accy)
sigma = np.std(nor_accy)

# Generate data points for the Gaussian curve
x = np.linspace(mu - 3*sigma, mu + 3*sigma, 1000)
y = norm.pdf(x, mu, sigma)

# Plot the Gaussian distribution
plt.figure(figsize=(8, 6))  # Adjust figure size as needed
plt.plot(x, y, label=f'Gaussian Curve ($\mu={mu:.2f}$, $\sigma={sigma:.2f}$)')
plt.title('Gaussian Distribution')
plt.xlabel('x')
plt.ylabel('Probability Density')
plt.grid(True)
plt.legend()

# Add vertical lines for mean and ±1σ, ±2σ
plt.axvline(mu, color='r', linestyle='--', linewidth=1, label=f'Mean ($\mu={mu:.2f}$)')
plt.axvline(mu + sigma, color='g', linestyle='--', linewidth=1, label=f'$\mu+\sigma={mu+sigma:.2f}$')
plt.axvline(mu - sigma, color='g', linestyle='--', linewidth=1, label=f'$\mu-\sigma={mu-sigma:.2f}$')
plt.axvline(mu + 2*sigma, color='b', linestyle='--', linewidth=1, label=f'$\mu+2\sigma={mu+2*sigma:.2f}$')
plt.axvline(mu - 2*sigma, color='b', linestyle='--', linewidth=1, label=f'$\mu-2\sigma={mu-2*sigma:.2f}$')

plt.legend()
plt.tight_layout()
plt.show()

"""# ANALYZING DATA OF VELOCITY X"""

start_time = pd.Timestamp('2023-07-01 00:00:00')
time_interval = pd.Timedelta(seconds=0.5)
timestamps = [start_time + i * time_interval for i in range(len(dfc['Vel X(m/s)']))]

# Create scatter plot
plt.figure(figsize=(10, 6))
plt.plot(timestamps, dfc['Vel X(m/s)'], alpha=0.6, color='g')

# Set plot title and labels
plt.title('Velocity vs Time')
plt.xlabel('Timestamp')
plt.ylabel('Velocity_X (m/s)')

# Improve the readability of the x-axis by formatting the timestamps
plt.gcf().autofmt_xdate()

nor_velx = np.array(dfc['Vel X(m/s)'])
nor_velx

mu = np.mean(nor_velx)
sigma = np.std(nor_velx)
print(mu)
print(sigma)

# Calculate mean and standard deviation
mu = np.mean(nor_velx)
sigma = np.std(nor_velx)

# Generate data points for the Gaussian curve
x = np.linspace(mu - 3*sigma, mu + 3*sigma, 1000)
y = norm.pdf(x, mu, sigma)

# Plot the Gaussian distribution
plt.figure(figsize=(8, 6))  # Adjust figure size as needed
plt.plot(x, y, label=f'Gaussian Curve ($\mu={mu:.2f}$, $\sigma={sigma:.2f}$)')
plt.title('Gaussian Distribution')
plt.xlabel('x')
plt.ylabel('Probability Density')
plt.grid(True)
plt.legend()

# Add vertical lines for mean and ±1σ, ±2σ
plt.axvline(mu, color='r', linestyle='--', linewidth=1, label=f'Mean ($\mu={mu:.2f}$)')
plt.axvline(mu + sigma, color='g', linestyle='--', linewidth=1, label=f'$\mu+\sigma={mu+sigma:.2f}$')
plt.axvline(mu - sigma, color='g', linestyle='--', linewidth=1, label=f'$\mu-\sigma={mu-sigma:.2f}$')
plt.axvline(mu + 2*sigma, color='b', linestyle='--', linewidth=1, label=f'$\mu+2\sigma={mu+2*sigma:.2f}$')
plt.axvline(mu - 2*sigma, color='b', linestyle='--', linewidth=1, label=f'$\mu-2\sigma={mu-2*sigma:.2f}$')

plt.legend()
plt.tight_layout()
plt.show()

"""# ANALYZING DATA VELOCITY Y"""

start_time = pd.Timestamp('2023-07-01 00:00:00')
time_interval = pd.Timedelta(seconds=0.5)
timestamps = [start_time + i * time_interval for i in range(len(dfc['Vel Y(m/s)']))]

# Create scatter plot
plt.figure(figsize=(10, 6))
plt.plot(timestamps, dfc['Vel Y(m/s)'], alpha=0.6, color='g')

# Set plot title and labels
plt.title('Velocity vs Time')
plt.xlabel('Timestamp')
plt.ylabel('Velocity_Y (m/s)')

# Improve the readability of the x-axis by formatting the timestamps
plt.gcf().autofmt_xdate()

nor_vely = np.array(dfc['Vel Y(m/s)'])
nor_vely

mu = np.mean(nor_vely)
sigma = np.std(nor_vely)
print(mu)
print(sigma)

# Calculate mean and standard deviation
mu = np.mean(nor_vely)
sigma = np.std(nor_vely)

# Generate data points for the Gaussian curve
x = np.linspace(mu - 3*sigma, mu + 3*sigma, 1000)
y = norm.pdf(x, mu, sigma)

# Plot the Gaussian distribution
plt.figure(figsize=(8, 6))  # Adjust figure size as needed
plt.plot(x, y, label=f'Gaussian Curve ($\mu={mu:.2f}$, $\sigma={sigma:.2f}$)')
plt.title('Gaussian Distribution')
plt.xlabel('x')
plt.ylabel('Probability Density')
plt.grid(True)
plt.legend()

# Add vertical lines for mean and ±1σ, ±2σ
plt.axvline(mu, color='r', linestyle='--', linewidth=1, label=f'Mean ($\mu={mu:.2f}$)')
plt.axvline(mu + sigma, color='g', linestyle='--', linewidth=1, label=f'$\mu+\sigma={mu+sigma:.2f}$')
plt.axvline(mu - sigma, color='g', linestyle='--', linewidth=1, label=f'$\mu-\sigma={mu-sigma:.2f}$')
plt.axvline(mu + 2*sigma, color='b', linestyle='--', linewidth=1, label=f'$\mu+2\sigma={mu+2*sigma:.2f}$')
plt.axvline(mu - 2*sigma, color='b', linestyle='--', linewidth=1, label=f'$\mu-2\sigma={mu-2*sigma:.2f}$')

plt.legend()
plt.tight_layout()
plt.show()

"""# ANALYZING DATA GYRO X"""

start_time = pd.Timestamp('2023-07-01 00:00:00')
time_interval = pd.Timedelta(seconds=0.5)
timestamps = [start_time + i * time_interval for i in range(len(dfc['Rot X(rad/s)']))]

# Create scatter plot
plt.figure(figsize=(10, 6))
plt.plot(timestamps, dfc['Rot X(rad/s)'], alpha=0.6, color='g')

# Set plot title and labels
plt.title('Rotation vs Time')
plt.xlabel('Timestamp')
plt.ylabel('Rotation X(rad/s)')

# Improve the readability of the x-axis by formatting the timestamps
plt.gcf().autofmt_xdate()

nor_rotx = np.array(dfc['Rot X(rad/s)'])
nor_rotx

mu = np.mean(nor_rotx)
sigma = np.std(nor_rotx)
print(mu)
print(sigma)

# Calculate mean and standard deviation
mu = np.mean(nor_rotx)
sigma = np.std(nor_rotx)

# Generate data points for the Gaussian curve
x = np.linspace(mu - 3*sigma, mu + 3*sigma, 1000)
y = norm.pdf(x, mu, sigma)

# Plot the Gaussian distribution
plt.figure(figsize=(8, 6))  # Adjust figure size as needed
plt.plot(x, y, label=f'Gaussian Curve ($\mu={mu:.2f}$, $\sigma={sigma:.2f}$)')
plt.title('Gaussian Distribution')
plt.xlabel('x')
plt.ylabel('Probability Density')
plt.grid(True)
plt.legend()

# Add vertical lines for mean and ±1σ, ±2σ
plt.axvline(mu, color='r', linestyle='--', linewidth=1, label=f'Mean ($\mu={mu:.2f}$)')
plt.axvline(mu + sigma, color='g', linestyle='--', linewidth=1, label=f'$\mu+\sigma={mu+sigma:.2f}$')
plt.axvline(mu - sigma, color='g', linestyle='--', linewidth=1, label=f'$\mu-\sigma={mu-sigma:.2f}$')
plt.axvline(mu + 2*sigma, color='b', linestyle='--', linewidth=1, label=f'$\mu+2\sigma={mu+2*sigma:.2f}$')
plt.axvline(mu - 2*sigma, color='b', linestyle='--', linewidth=1, label=f'$\mu-2\sigma={mu-2*sigma:.2f}$')

plt.legend()
plt.tight_layout()
plt.show()

"""# ANALYZING DATA GYRO Y"""

start_time = pd.Timestamp('2023-07-01 00:00:00')
time_interval = pd.Timedelta(seconds=0.5)
timestamps = [start_time + i * time_interval for i in range(len(dfc['Rot X(rad/s)']))]

# Create scatter plot
plt.figure(figsize=(10, 6))
plt.scatter(timestamps, dfc['Rot X(rad/s)'], alpha=0.6, color='g')

# Set plot title and labels
plt.title('Rotation vs Time')
plt.xlabel('Timestamp')
plt.ylabel('Rotation X(rad/s)')

# Improve the readability of the x-axis by formatting the timestamps
plt.gcf().autofmt_xdate()

nor_roty = np.array(dfc['Rot X(rad/s)'])
nor_roty

mu = np.mean(nor_roty)
sigma = np.std(nor_roty)
print(mu)
print(sigma)

# Calculate mean and standard deviation
mu = np.mean(nor_roty)
sigma = np.std(nor_roty)

# Generate data points for the Gaussian curve
x = np.linspace(mu - 3*sigma, mu + 3*sigma, 1000)
y = norm.pdf(x, mu, sigma)

# Plot the Gaussian distribution
plt.figure(figsize=(8, 6))  # Adjust figure size as needed
plt.plot(x, y, label=f'Gaussian Curve ($\mu={mu:.2f}$, $\sigma={sigma:.2f}$)')
plt.title('Gaussian Distribution')
plt.xlabel('x')
plt.ylabel('Probability Density')
plt.grid(True)
plt.legend()

# Add vertical lines for mean and ±1σ, ±2σ
plt.axvline(mu, color='r', linestyle='--', linewidth=1, label=f'Mean ($\mu={mu:.2f}$)')
plt.axvline(mu + sigma, color='g', linestyle='--', linewidth=1, label=f'$\mu+\sigma={mu+sigma:.2f}$')
plt.axvline(mu - sigma, color='g', linestyle='--', linewidth=1, label=f'$\mu-\sigma={mu-sigma:.2f}$')
plt.axvline(mu + 2*sigma, color='b', linestyle='--', linewidth=1, label=f'$\mu+2\sigma={mu+2*sigma:.2f}$')
plt.axvline(mu - 2*sigma, color='b', linestyle='--', linewidth=1, label=f'$\mu-2\sigma={mu-2*sigma:.2f}$')

plt.legend()
plt.tight_layout()
plt.show()

"""#ACCELRATION OF STEERING AND COG"""

df['Acc X(m/s^2)']

dfc['Acc X(m/s^2)']

# Find the length of the shortest dataset
min_length = min(len(df['Acc X(m/s^2)']), len(dfc['Acc X(m/s^2)']))

# Generate timestamps based on the shortest dataset
start_time = pd.Timestamp('2023-07-01 00:00:00')
time_interval = pd.Timedelta(seconds=0.5)
timestamps = [start_time + i * time_interval for i in range(min_length)]

# Slice the datasets to match the shortest length
df_steering_trimmed = df['Acc X(m/s^2)'][:min_length]
dfc_cog_trimmed = dfc['Acc X(m/s^2)'][:min_length]

# Create scatter plot for both accelerations
plt.figure(figsize=(10, 6))
plt.plot(timestamps, df_steering_trimmed, alpha=0.6, color='g', label='Steering Acceleration')
plt.plot(timestamps, dfc_cog_trimmed, alpha=0.6, color='b', label='COG Acceleration')

# Set plot title and labels
plt.title('Acceleration vs Time')
plt.xlabel('Timestamp')
plt.ylabel('Acceleration_X (m/s^2)')
plt.legend()

# Improve the readability of the x-axis by formatting the timestamps
plt.gcf().autofmt_xdate()

plt.show()

# Find the length of the shortest dataset
min_length = min(len(df['Acc Y(m/s^2)']), len(dfc['Acc Y(m/s^2)']))

# Generate timestamps based on the shortest dataset
start_time = pd.Timestamp('2023-07-01 00:00:00')
time_interval = pd.Timedelta(seconds=0.5)
timestamps = [start_time + i * time_interval for i in range(min_length)]

# Slice the datasets to match the shortest length
df_steering_trimmed = df['Acc Y(m/s^2)'][:min_length]
dfc_cog_trimmed = dfc['Acc Y(m/s^2)'][:min_length]

# Create scatter plot for both accelerations
plt.figure(figsize=(10, 6))
plt.plot(timestamps, df_steering_trimmed, alpha=0.6, color='g', label='Steering Acceleration')
plt.plot(timestamps, dfc_cog_trimmed, alpha=0.6, color='b', label='COG Acceleration')

# Set plot title and labels
plt.title('Acceleration vs Time')
plt.xlabel('Timestamp')
plt.ylabel('Acceleration_Y (m/s^2)')
plt.legend()

# Improve the readability of the x-axis by formatting the timestamps
plt.gcf().autofmt_xdate()

plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

# Calculate mean and standard deviation
mean_accx = np.mean(nor_accx)
std_accx = np.std(nor_accx)
mean_accx_steer = np.mean(nor_accx_steer)
std_accx_steer = np.std(nor_accx_steer)

# Plot the histograms
plt.hist(nor_accx, bins=10, density=True, alpha=0.6, color='g', label='Acc X')
plt.hist(nor_accx_steer, bins=10, density=True, alpha=0.6, color='b', label='Acc X Steer')

# Plot the normal distribution curves
xmin, xmax = plt.xlim()
x = np.linspace(xmin, xmax, 100)
p1 = stats.norm.pdf(x, mean_accx, std_accx)
p2 = stats.norm.pdf(x, mean_accx_steer, std_accx_steer)
plt.plot(x, p1, 'g', linewidth=2, label='Acc X Normal Curve')
plt.plot(x, p2, 'b', linewidth=2, label='Acc X Steer Normal Curve')

# Add mean and standard deviation lines
plt.axvline(mean_accx, color='g', linestyle='dashed', linewidth=1)
plt.axvline(mean_accx_steer, color='b', linestyle='dashed', linewidth=1)
plt.axvline(mean_accx + std_accx, color='g', linestyle='dotted', linewidth=1)
plt.axvline(mean_accx - std_accx, color='g', linestyle='dotted', linewidth=1)
plt.axvline(mean_accx_steer + std_accx_steer, color='b', linestyle='dotted', linewidth=1)
plt.axvline(mean_accx_steer - std_accx_steer, color='b', linestyle='dotted', linewidth=1)

# Add text annotations for mean and standard deviation
plt.text(mean_accx, max(p1)/2, f'Mean: {mean_accx:.2f}\nStd: {std_accx:.2f}', color='g')
plt.text(mean_accx_steer, max(p2)/2, f'Mean: {mean_accx_steer:.2f}\nStd: {std_accx_steer:.2f}', color='r')

# Add labels and title
title = "Normalized 'Acc X(m/s^2)' - Z-Scores"
plt.title(title)
plt.xlabel('Z-Score')
plt.ylabel('Density')
plt.legend()

# Zoom in on the graph
plt.xlim(-3, 3)

# Show the plot
plt.show()



"""#ROTATION COMPARISON"""

# Find the length of the shortest dataset
min_length = min(len(df['Rot X(rad/s)']), len(dfc['Rot X(rad/s)']))

# Generate timestamps based on the shortest dataset
start_time = pd.Timestamp('2023-07-01 00:00:00')
time_interval = pd.Timedelta(seconds=0.5)
timestamps = [start_time + i * time_interval for i in range(min_length)]

# Slice the datasets to match the shortest length
df_steering_trimmed = df['Rot X(rad/s)'][:min_length]
dfc_cog_trimmed = dfc['Rot X(rad/s)'][:min_length]

# Create scatter plot for both accelerations
plt.figure(figsize=(10, 6))
plt.plot(timestamps, df_steering_trimmed, alpha=0.6, color='g', label='Steering Rotation')
plt.plot(timestamps, dfc_cog_trimmed, alpha=0.6, color='b', label='COG Rotation')

# Set plot title and labels
plt.title('Rotation vs Time')
plt.xlabel('Timestamp')
plt.ylabel('Rotation_X (rad/s)')
plt.legend()

# Improve the readability of the x-axis by formatting the timestamps
plt.gcf().autofmt_xdate()

plt.show()

"""#VELOCITY COMPARISON"""

# Find the length of the shortest dataset
min_length = min(len(df['Vel X(m/s)']), len(dfc['Vel X(m/s)']))

# Generate timestamps based on the shortest dataset
start_time = pd.Timestamp('2023-07-01 00:00:00')
time_interval = pd.Timedelta(seconds=0.5)
timestamps = [start_time + i * time_interval for i in range(min_length)]

# Slice the datasets to match the shortest length
df_steering_trimmed = df['Vel X(m/s)'][:min_length]
dfc_cog_trimmed = dfc['Vel X(m/s)'][:min_length]

# Create scatter plot for both accelerations
plt.figure(figsize=(10, 6))
plt.plot(timestamps, df_steering_trimmed, alpha=0.6, color='g', label='Steering Velocity')
plt.plot(timestamps, dfc_cog_trimmed, alpha=0.6, color='b', label='COG Velocity')

# Set plot title and labels
plt.title('Velocity vs Time')
plt.xlabel('Timestamp')
plt.ylabel('Velocity_X (m/s)')
plt.legend()

# Improve the readability of the x-axis by formatting the timestamps
plt.gcf().autofmt_xdate()

plt.show()

"""#ROLL AND PITCH COMPARISON"""

# Find the length of the shortest dataset
min_length = min(len(df['Inclin X(deg)']), len(dfc['Inclin X(deg)']))

# Generate timestamps based on the shortest dataset
start_time = pd.Timestamp('2023-07-01 00:00:00')
time_interval = pd.Timedelta(seconds=0.5)
timestamps = [start_time + i * time_interval for i in range(min_length)]

# Slice the datasets to match the shortest length
df_steering_trimmed = df['Inclin X(deg)'][:min_length]
dfc_cog_trimmed = dfc['Inclin X(deg)'][:min_length]

# Create scatter plot for both accelerations
plt.figure(figsize=(10, 6))
plt.plot(timestamps, df_steering_trimmed, alpha=0.6, color='g', label='Steering Roll')
plt.plot(timestamps, dfc_cog_trimmed, alpha=0.6, color='b', label='COG Roll')

# Set plot title and labels
plt.title('Roll vs Time')
plt.xlabel('Timestamp')
plt.ylabel('Roll (deg/s)')
plt.legend()

# Improve the readability of the x-axis by formatting the timestamps
plt.gcf().autofmt_xdate()

plt.show()

# Find the length of the shortest dataset
min_length = min(len(df['Inclin Y(deg)']), len(dfc['Inclin Y(deg)']))

# Generate timestamps based on the shortest dataset
start_time = pd.Timestamp('2023-07-01 00:00:00')
time_interval = pd.Timedelta(seconds=0.5)
timestamps = [start_time + i * time_interval for i in range(min_length)]

# Slice the datasets to match the shortest length
df_steering_trimmed = df['Inclin Y(deg)'][:min_length]
dfc_cog_trimmed = dfc['Inclin Y(deg)'][:min_length]

# Create scatter plot for both accelerations
plt.figure(figsize=(10, 6))
plt.plot(timestamps, df_steering_trimmed, alpha=0.6, color='g', label='Steering Pitch')
plt.plot(timestamps, dfc_cog_trimmed, alpha=0.6, color='b', label='COG Pitch')

# Set plot title and labels
plt.title('Pitch vs Time')
plt.xlabel('Timestamp')
plt.ylabel('Pitch (deg/s)')
plt.legend()

# Improve the readability of the x-axis by formatting the timestamps
plt.gcf().autofmt_xdate()

plt.show()
